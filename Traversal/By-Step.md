# by步骤

`by()`步骤并不是一个实际的步骤，和`as()`、`option()`同样，是一个“步骤调节器”。如果一个步骤能够输入遍历，函数，比较器等，`by()`就意味着将他们加入进来。通常的表达式为`step().by()...by()`。一些可以被任意计算的步骤只能输入一个`by()`。

```groovy
gremlin> g.V().group().by(bothE().count()) //1\
==>[1:[v[2],v[5],v[6]],3:[v[1],v[3],v[4]]]
gremlin> g.V().group().by(bothE().count()).by('name') //2\
==>[1:[vadas,ripple,peter],3:[marko,lop,josh]]
gremlin> g.V().group().by(bothE().count()).by(count()) //3\
==>[1:3,3:3]
```

1. `by(outE().count())`将通过边的总数来分组（遍历）。
2. `by('name')`将通过元素的名字来分组（元素属性映射）。
3. `by(count())`将在每一个组中统计遍历到的所有的元素的数量（遍历）。

下面的步骤都支持`by()`调节器。记录下这些调节器的语法能够帮助更好的理解，在他们各自的文档中也都有讨论。

* `dedup()`：`by()`调节器的结果去重。
* `cyclicPath()`：过滤遍历路径中的环路。
* `simplePath()`：过滤简单的遍历路径。
* `sample()`：样品使用`by()`调节器返回的结果。
* `where()`：确定`by()`调节器给定的测试结果的条件。
* `groupCount()`：计算`by()`调节器结果中的组的键数量。
* `group()`：通过`by()`调节器创建组的键值对。
* `order()`：给`by()`调节器的结果排序。
* `path()`：获取有所有遍历到的元素的遍历路径。
* `projects()`：映射一个有各种结果的图来调试当前对象。
* `select()`：选择路径中的元素并转换。
* `tree()`：获取通过`by()`调节器的遍历遍历树。
* `aggregate()`：聚合所有元素到集合中，只存储`by()`调节器的值。
* `store()`：存储所有元素到集合中，只存储`by()`调节器的值。

